senha sql server: sa curitiba

/* DENTRO DO SQÇ SERVER, AO CONECTAR-SE
 - MASTER: TODAS AS INFORMAÇÕES DOS BANCO DE
 DADOS CRIADOS NO SQL SERVER

 - MODEL: SQL SERVER NÃO CRIA TABELAS DO ZERO, ELE 
COPIA A BASE MODEL

 - MSDB: AGENDAMENTO DE ROTINAS
 		DADOS DE INTERGRATION SERVICES, ETL DA
 		MICROSOFT (EXTRAÇÃO, TRANSFORMAÇÃO E CARGA)

 - TEMPDB: TABELAS TEMPORARIAS Q SÃO APAGADAS AUTO.

 O SQL SERVER TRABALHA COM PROCESSAMETO ASSINCRONO
 
 GO É O DELIMITADOR DO SQL SERVER

 NO PAINEL DO SQL SERVER, OS CÓDIGOS SÃO ENCAPSULADOS
 EM PACOTES TCP/IP, SENDO ENVIADOS PARA O SERVIDOR
 O GO É RESPONSÁVEL POR QUEBRAR AS SQL EM PACOTES
 DEIXANDO O PROCESSAMENTO ASSINCRONO ORDENADO CORRETA
 MENTE

 TIPOS DE ARQUIVOS
 	- MDF: MASTER DATA FILE
		ARMAZENA DADOS -> AO PREENCHER UMA TABELA É
		GERADA UMA TRANSAÇÃO, CARACTERISTICA DE UM
		BANCO RELACIONAL (ACID)

 	- LOG DATA FILE
 		ARMAZENDA OS LOGS
 			BEGIN, ROLLBACK E COMMIT
	
	A MICROSOFT RECOMENDA Q O MDF SEJA DESTINADO EX
	CLUSIVAMENTE A DADOS DO SISTEMA (DICIONARIO)
	- NDF, ORGANIZADO EM GRUPO DE DADOS

TODO BANCO TEM UM GRUPO PADRAO CHAMADO PRIMARY. E O 
MDF VAI DENTRO DELE POR PADRÃO
*/


/*
	ORGANIZAR FISICAMENTE E LOGICAMENTE UM BANCO DE
	DADOS

	1 - CRIAR O DB COM ARQUIVOS PARA OS SETORES DE MKT
	E RH
	2 - CRIAR UM ARQUIVO GERAL
	3 - DEIXAR O MDF APENAS COM O DICIONARIO DE DADOS
	4 - CRIAR 2 GRUPOS DE ARQUIVOS

	ENTÃO: CRIE UM NOVO DB, VA EM GRUPO DE ARQUIVOS
	CRIE 3 GRUPOS: GA_MARKETING, GA_VENDAS, GA_GERAL 

	MARQUE COMO PADRÃO O GRUPO GA_GERAL

	DEPOIS ADICIONE OS ARQUIVOS EM GERAL E O NOME.NDF
	DE CADA UM

	
*/




USE EMPRESA
GO

CREATE TABLE T_EMPRESA(
	ID INT,
	NOME VARCHAR(50)
)
GO


CREATE TABLE ALUNO(
	IDALUNO INT PRIMARY KEY IDENTITY,
	NOME VARCHAR(30) NOT NULL, 
	SEXO CHAR(1) NOT NULL,
	NASCIMENTO DATE NOT NULL,
	EMAIL VARCHAR(30) UNIQUE	
)
GO
-- CONSTRAINTS, 'ENUM'
ALTER TABLE  ALUNO
ADD CONSTRAINT CK_SEXO CHECK (SEXO IN('M', 'F'))
GO

-- RELACIONAMENTO 1 X 1

CREATE TABLE ENDERECO (
	IDENDERECO INT PRIMARY KEY IDENTITY(100,10),
	BAIRRO VARCHAR(30),
	UF CHAR(2) NOT NULL,
	CHECK (UF IN('RJ','SP', 'MG')),
	ID_ALUNO INT UNIQUE
) 
GO
-- FK
ALTER TABLE ENDERECO ADD CONSTRAINT FK_ENDERECO_ALUNO
FOREIGN KEY (ID_ALUNO) REFERENCES ALUNO(IDALUNO);
GO

-- COMANDOS DE DESCRIÇÃO
-- DESC,SHOW CREATE TABLE. PROCEDURES CRIADAS E ARMAZENADAS
-- SP_ -> STORAGE PROCEDURE
SP_COLUMNS ALUNO
GO
SP_HELP ALUNO 
GO

INSERT INTO ALUNO VALUES('ANDRE','M','1981/12/09','ANDRE@IG.COM')
INSERT INTO ALUNO VALUES('ANA','F','1978/03/09','ANA@IG.COM')
INSERT INTO ALUNO VALUES('RUI','M','1951/07/09','RUI@IG.COM')
INSERT INTO ALUNO VALUES('JOAO','M','2002/11/09','JOAO@IG.COM')
GO

SELECT * FROM ALUNO
GO


INSERT INTO ENDERECO VALUES('FLAMENGO','RJ',1)
INSERT INTO ENDERECO VALUES('MORUMBI','SP',2)
INSERT INTO ENDERECO VALUES('CENTRO','MG',3)
INSERT INTO ENDERECO VALUES('CENTRO','SP',4)
GO

SELECT * FROM ENDERECO 
GO

-- RELACIONAMENTO 1 X N
CREATE TABLE TELEFONE(
	IDTELEFONE INT PRIMARY KEY IDENTITY,
	TIPO CHAR(3) NOT NULL,
	NUMERO VARCHAR(10) NOT NULL,
	ID_ALUNO INT,
	CHECK (TIPO IN ('RES', 'COM', 'CEL'))
)
GO

ALTER TABLE TELEFONE ADD CONSTRAINT FK_TELEFONE_ALUNO
FOREIGN KEY (ID_ALUNO) REFERENCES ALUNO(IDALUNO)
GO

INSERT INTO TELEFONE VALUES('CEL','7899889',1)
INSERT INTO TELEFONE VALUES('RES','4325444',1)
INSERT INTO TELEFONE VALUES('COM','4354354',2)
INSERT INTO TELEFONE VALUES('CEL','2344556',2)
GO

SELECT * FROM TELEFONE
GO

/* PEGAR DATA ATUAL */

SELECT GETDATE()
GO

-- CLAUSULA AMBÍGUA
SELECT NOME, SEXO, EMAIL, T.NUMERO, E.BAIRRO 
FROM ALUNO 
INNER JOIN ENDERECO E
ON E.ID_ALUNO = IDALUNO
LEFT JOIN TELEFONE T
ON T.ID_ALUNO = IDALUNO
GO

-- IFNULL
SELECT	NOME, 
		SEXO, 
		EMAIL, 
		ISNULL(T.NUMERO, '------'), 
		E.BAIRRO 
FROM ALUNO 
INNER JOIN ENDERECO E
ON E.ID_ALUNO = IDALUNO
LEFT JOIN TELEFONE T
ON T.ID_ALUNO = IDALUNO
GO

-- DATAS

SELECT	NOME, 
		NASCIMENTO 
FROM ALUNO
GO

--  DATEDIFF - DIFERENÇA ENTRE DATAS
SELECT NOME, NASCIMENTO, DATEDIFF(YEAR, NASCIMENTO, GETDATE()) AS IDADE
FROM ALUNO
GO

SELECT NOME, NASCIMENTO, DATEDIFF(DAY, NASCIMENTO, GETDATE())/365 AS IDADE
FROM ALUNO
GO

--  DATENAME - RETORNA UMA STRING
SELECT NOME, NASCIMENTO, DATENAME( MONTH, NASCIMENTO) AS 'MÊS NASC'
FROM ALUNO
GO

-- DATEPART - RETORNA UM INTEIRO
SELECT NOME, NASCIMENTO, DATEPART(MONTH, NASCIMENTO) AS 'MÊS'
FROM ALUNO
GO

-- DATEADD
SELECT NOME, DATEADD(MONTH, 30, NASCIMENTO) FROM ALUNO
GO

-- CONVERSÃO DE DADOS
-- SQL SERVER SEMPRE TENTA CONVERTER STRING PARA NUMERICO
-- OPERADOR + CONCATENA OU SOMA
-- DATA CONVERSION TYPES SQL SERVER
SELECT 1 + '1 1'
GO


-- FUNÇÃO DE CONVERSÃO DE DADOS
SELECT '1' + '100';
GO 
-- 1100

SELECT CAST('10' AS INT) + '100';
GO
-- 110

-- FORMATO DE DATA BR
SELECT	NOME,
		CAST(DAY(NASCIMENTO) AS varchar) + '/' + 
		CAST(MONTH(NASCIMENTO) AS VARCHAR) + '/' + 
		CAST(YEAR(NASCIMENTO) AS VARCHAR) AS 'NASCIMENTO'
FROM ALUNO
GO

-- CHARINDEX - RETORNA UM INT BASEADO EM UMA CONDIÇÃO
-- OQ, ONDE, A PARTIR DE
SELECT NOME, CHARINDEX('A', NOME) FROM ALUNO
GO
SELECT NOME, CHARINDEX('A', NOME, 2) FROM ALUNO
GO


-- BULK INSERT - IMPORTAÇÃO DE ARQUIVOS
CREATE TABLE LANCAMENTO_CONTABIL(
	CONTA INT,
	VALOR BIGINT,
	DEC_CRED CHAR(1)
)
GO



SELECT * FROM LANCAMENTO_CONTABIL
GO

-- \t TAB
BULK INSERT LANCAMENTO_CONTABIL
FROM 'C:\Users\gusta\OneDrive\Documents\Banco de Dados\CONTAS.txt'
WITH
(
	FIRSTROW = 2,
	DATAFILETYPE = 'char',
	FIELDTERMINATOR = '\t',
	ROWTERMINATOR = '\n'
		
)
GO
 
-- MOSTRAR OS 10 PRIMEIROS
SELECT TOP 10 * FROM LANCAMENTO_CONTABIL
GO
SELECT * FROM LANCAMENTO_CONTABIL
GO

SELECT DEC_CRED, COUNT(DEC_CRED) AS SOMA 
FROM LANCAMENTO_CONTABIL GROUP BY DEC_CRED
GO

SELECT COUNT(DEC_CRED) AS NULOS 
FROM LANCAMENTO_CONTABIL 
WHERE DEC_CRED = NULL
GO

SELECT SUM(C3.VALOR) FROM LANCAMENTO_CONTABIL C3
		WHERE C3.DEC_CRED = 'C'
GO

-- SALDO DA CONTA, MINHA VERSÃO (NOOB)
SELECT	C1.CONTA, 
		(SELECT SUM(C2.VALOR) FROM LANCAMENTO_CONTABIL C2
		WHERE C2.DEC_CRED = 'C' AND C1.CONTA = C2.CONTA) - 
		(SELECT SUM(C3.VALOR) FROM LANCAMENTO_CONTABIL C3
		WHERE C3.DEC_CRED = 'D' AND C1.CONTA = C3.CONTA) 
		AS 'SOMA CREDOR - DEVEDOR'
FROM LANCAMENTO_CONTABIL C1
GROUP BY C1.CONTA ORDER BY C1.CONTA
GO

-- ENTENDENDO O MULTIPLICADOR
-- A IDEIA É SOMAR QUANDO C E SUBTRAIR QUANDO D
-- 2X - 1, ONDE X = 1 OU 0 -> Y = 1 OU -1
SELECT CONTA, VALOR, DEC_CRED,
CHARINDEX('D',DEC_CRED) AS DEBITO,
CHARINDEX('C',DEC_CRED) AS CREDITO,
CHARINDEX('C',DEC_CRED) * 2 - 1 AS MULTIPLICADOR
FROM LANCAMENTO_CONTABIL
GO

SELECT CONTA,
SUM(VALOR * (CHARINDEX('C',DEC_CRED) * 2 - 1)) AS SALDO
FROM LANCAMENTO_CONTABIL
GROUP BY CONTA ORDER BY CONTA
GO

-- CONTA QUANTAS CONTAS
SELECT COUNT(DISTINCT  CONTA) FROM LANCAMENTO_CONTABIL
GO

-- TRIGGERS
CREATE TABLE PRODUTOS(
	IDPRODUTO INT IDENTITY PRIMARY KEY,
	NOME VARCHAR(50) NOT NULL,
	CATEGORIA VARCHAR(30) NOT NULL,
	PRECO NUMERIC(10,2) NOT NULL
)
GO

CREATE TABLE HISTORICO(
	IDOPERACAO INT PRIMARY KEY IDENTITY,
	PRODUTO VARCHAR(50) NOT NULL,
	CATEGORIA VARCHAR(30) NOT NULL,
	PRECOANTIGO NUMERIC(10,2) NOT NULL,
	PRECONOVO NUMERIC(10,2) NOT NULL,
	DATA DATETIME,
	USUARIO VARCHAR(30),
	MENSAGEM VARCHAR(100)
)
GO

INSERT INTO PRODUTOS VALUES('LIVRO SQL SERVER','LIVROS',98.00)
INSERT INTO PRODUTOS VALUES('LIVRO ORACLE','LIVROS',50.00)
INSERT INTO PRODUTOS VALUES('LICENÇA POWERCENTER','SOFTWARES',45000.00)
INSERT INTO PRODUTOS VALUES('NOTEBOOK I7','COMPUTADORES',3150.00)
INSERT INTO PRODUTOS VALUES('LIVRO BUSINESS INTELLIGENCE','LIVROS',90.00)
GO

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO
GO

SELECT SUSER_NAME()
GO

/*
SCHEMA É UM DIVISOR LOGICO DE UM BANCO DE DADOS
TUDO QUE É CRIADO EM UM DB, PRECISA TER UM OWNER
SE CRIAR SEM EXPLICITAR QUEM É O DONO, O DONO SERÁ
O DBO (DATABASE OWNER)
*/

-- TRIGGER DE DML, UPDATE
-- SQL SERVER TEM DUAS ÁREAS (INSERTED, DELETED)
-- UPDATE USA AS DUAS
CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE
AS
		DECLARE @IDPRODUTO INT
		DECLARE @PRODUTO VARCHAR(30)
		DECLARE @CATEGORIA VARCHAR(10)
		DECLARE @PRECO NUMERIC(10,2)
		DECLARE @PRECONOVO NUMERIC(10,2)
		DECLARE @DATA DATETIME
		DECLARE @USUARIO VARCHAR(30)
		DECLARE @ACAO VARCHAR(100)

		--PRIMEIRO BLOCO
		SELECT @IDPRODUTO = IDPRODUTO FROM inserted
		SELECT @PRODUTO = NOME FROM inserted
		SELECT @CATEGORIA = CATEGORIA FROM inserted
		SELECT @PRECO = PRECO FROM deleted
		SELECT @PRECONOVO = PRECO FROM inserted

		--SEGUNDO BLOCO
		SET @DATA = GETDATE()
		SET @USUARIO = SUSER_NAME()
		SET @ACAO = 'VALOR INSERIDO PELA TRIGGER TRG_ATUALIZA_PRECO'

		INSERT INTO HISTORICO
		(PRODUTO,CATEGORIA,PRECOANTIGO,PRECONOVO,DATA,USUARIO,MENSAGEM)
		VALUES
		(@PRODUTO,@CATEGORIA,@PRECO,@PRECONOVO,@DATA,@USUARIO,@ACAO)

		PRINT 'TRIGGER EXECUTADA COM SUCESSO'
GO

DROP TRIGGER TRG_ATUALIZA_PRECO
GO
-- TESTE
UPDATE PRODUTOS SET PRECO = 17.45
WHERE IDPRODUTO = 3
GO

UPDATE PRODUTOS SET NOME = 'TESTE' 
WHERE IDPRODUTO = 1

SELECT * FROM HISTORICO
GO

-- CORRIGINDO PARA APENAS QUANDO O VALOR FOR ALTERADO
CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE AS
IF UPDATE(PRECO) -- TSQL
BEGIN
		DECLARE @IDPRODUTO INT
		DECLARE @PRODUTO VARCHAR(30)
		DECLARE @CATEGORIA VARCHAR(10)
		DECLARE @PRECO NUMERIC(10,2)
		DECLARE @PRECONOVO NUMERIC(10,2)
		DECLARE @DATA DATETIME
		DECLARE @USUARIO VARCHAR(30)
		DECLARE @ACAO VARCHAR(100)

		--PRIMEIRO BLOCO
		SELECT @IDPRODUTO = IDPRODUTO FROM inserted
		SELECT @PRODUTO = NOME FROM inserted
		SELECT @CATEGORIA = CATEGORIA FROM inserted
		SELECT @PRECO = PRECO FROM deleted
		SELECT @PRECONOVO = PRECO FROM inserted

		--SEGUNDO BLOCO
		SET @DATA = GETDATE()
		SET @USUARIO = SUSER_NAME()
		SET @ACAO = 'VALOR INSERIDO PELA TRIGGER TRG_ATUALIZA_PRECO'

		INSERT INTO HISTORICO
		(PRODUTO,CATEGORIA,PRECOANTIGO,PRECONOVO,DATA,USUARIO,MENSAGEM)
		VALUES
		(@PRODUTO,@CATEGORIA,@PRECO,@PRECONOVO,@DATA,@USUARIO,@ACAO)

		PRINT 'TRIGGER EXECUTADA COM SUCESSO'
END
GO

DROP TRIGGER TRG_ATUALIZA_PRECO
GO

CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE
AS
BEGIN
    IF UPDATE(PRECO) -- TSQL
    BEGIN
        DECLARE @DATA DATETIME
        DECLARE @USUARIO VARCHAR(30)
        DECLARE @ACAO VARCHAR(100)

        -- Inicializar variáveis comuns
        SET @DATA = GETDATE()
        SET @USUARIO = SUSER_NAME()
        SET @ACAO = 'VALOR INSERIDO PELA TRIGGER TRG_ATUALIZA_PRECO'

        -- Inserir no histórico para cada linha atualizada
        INSERT INTO HISTORICO
        (PRODUTO, CATEGORIA, PRECOANTIGO, PRECONOVO, DATA, USUARIO, MENSAGEM)
        SELECT 
            I.NOME,
            I.CATEGORIA,
            D.PRECO AS PRECOANTIGO,
            I.PRECO AS PRECONOVO,
            @DATA,
            @USUARIO,
            @ACAO
        FROM 
            INSERTED I
        JOIN 
            DELETED D ON I.IDPRODUTO = D.IDPRODUTO

        PRINT 'TRIGGER EXECUTADA COM SUCESSO'
    END
END
GO
-- SIMPLIFICAR A DECLARAÇÃO DAS TRIGGERS (ESTÁ ERRADO)
CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE AS
IF UPDATE(PRECO) -- TSQL
BEGIN
		INSERT INTO HISTORICO
		(PRODUTO,CATEGORIA,PRECOANTIGO,PRECONOVO,DATA,USUARIO,MENSAGEM)
		VALUES(
			(SELECT NOME FROM INSERTED),
			(SELECT CATEGORIA FROM INSERTED),
			(SELECT PRECO FROM DELETED),
			(SELECT PRECO FROM INSERTED),
			(SELECT GETDATE()),
			(SELECT SUSER_NAME()),
			(SELECT 'VALOR INSERIDO')
			)
		PRINT 'TRIGGER EXECUTADA COM SUCESSO'
END
GO

-- OU AINDA
CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE AS
IF UPDATE(PRECO) -- TSQL 
BEGIN
	INSERT INTO HISTORICO
		(PRODUTO,CATEGORIA,PRECOANTIGO,PRECONOVO,DATA,USUARIO,MENSAGEM)
		(SELECT I.NOME, I.CATEGORIA, D.PRECO,
			I.PRECO, GETDATE(), SUSER_NAME(), 'VALOR INSERIDO' 
			FROM DELETED D, INSERTED I
			WHERE D.IDPRODUTO = I.IDPRODUTO)
	PRINT 'TRIGGER EXECUTADA COM SUCESSO'
END
GO

CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE AS
IF UPDATE(PRECO) -- TSQL 
BEGIN
	INSERT INTO HISTORICO
		(PRODUTO,CATEGORIA,PRECOANTIGO,PRECONOVO,DATA,USUARIO,MENSAGEM)
		(SELECT I.NOME, I.CATEGORIA, D.PRECO,
			I.PRECO, GETDATE(), SUSER_NAME(), 'VALOR INSERIDO' 
			FROM DELETED D 
			JOIN INSERTED I ON 
			D.IDPRODUTO = I.IDPRODUTO)
	PRINT 'TRIGGER EXECUTADA COM SUCESSO'
END
GO

DELETE FROM HISTORICO
GO

UPDATE PRODUTOS SET PRECO = PRECO * 1.2
GO

SELECT * FROM HISTORICO
GO


-- SALARIO ANTIGO, NOVO, DATA E NOME DO EMPREGO
CREATE TABLE SALARIO_RANGE(
	MINSAL MONEY,
	MAXSAL MONEY
)
GO
CREATE TABLE EMPREGADO(
	IDEMP INT PRIMARY KEY,
	NOME VARCHAR(30),
	SALARIO MONEY,
	IDGERENTE INT
)
GO
ALTER TABLE EMPREGADO ADD CONSTRAINT FK_GERENTE
FOREIGN KEY(IDGERENTE) REFERENCES EMPREGADO(IDEMP)
GO

INSERT INTO EMPREGADO VALUES(1,'CLARA',5000.00,NULL)
INSERT INTO EMPREGADO VALUES(2,'CELIA',4000.00,1)
INSERT INTO EMPREGADO VALUES(3,'JOAO',4000.00,1)
GO


INSERT INTO SALARIO_RANGE VALUES(2000.00, 6000.00);
GO

SELECT * FROM SALARIO_RANGE
GO

CREATE TRIGGER TG_RANGE
ON DBO.EMPREGADO
FOR INSERT, UPDATE
AS
	DECLARE @MINSAL MONEY,
			@MAXSAL MONEY,
			@ATUALSAL MONEY

	SELECT @MINSAL = MINSAL, @MAXSAL = MAXSAL 
	FROM SALARIO_RANGE

	SELECT @ATUALSAL = I.SALARIO
	FROM INSERTED I

	IF(@ATUALSAL < @MINSAL)
	BEGIN
		RAISERROR('SALARIO MENOR QUE O PISO', 16, 1)	
		ROLLBACK TRANSACTION
	END

	ELSE IF(@ATUALSAL > @MAXSAL)
	BEGIN
		RAISERROR('SALARIO MAIOR QUE O TETO', 16, 1)
		ROLLBACK TRANSACTION
	END
GO

SELECT * FROM EMPREGADO
GO

UPDATE EMPREGADO SET SALARIO = 9000.00
WHERE IDEMP = 1
GO

UPDATE EMPREGADO SET SALARIO = 1000.00
WHERE IDEMP = 1
GO

-- VERIFICANDO O CODIGO DE UMA TRIGGER
SP_HELPTEXT TG_RANGE
GO

DROP TABLE PESSOA
GO

CREATE TABLE PESSOA(
	IDPESSOA INT PRIMARY KEY IDENTITY,
	NOME VARCHAR(30) NOT NULL,
	SEXO CHAR(1) NOT NULL CHECK (SEXO IN('M','F')), --ENUM
	MASCIMENTO DATE NOT NULL
)
GO

DROP TABLE TELEFONE
GO

CREATE TABLE TELEFONE(
	IDTELEFONE INT NOT NULL IDENTITY,
	TIPO CHAR(3) NOT NULL CHECK ( TIPO IN('CEL','COM')),
	NUMERO CHAR(10) NOT NULL,
	ID_PESSOA INT
)
GO

ALTER TABLE TELEFONE ADD CONSTRAINT FK_TELEFONE_PESSOA
FOREIGN KEY(ID_PESSOA) REFERENCES PESSOA(IDPESSOA)
ON DELETE CASCADE
GO

DELETE FROM PESSOA
GO

INSERT INTO PESSOA VALUES('ANTONIO','M','1981-02-13')
INSERT INTO PESSOA VALUES('DANIEL','M','1985-03-18')
INSERT INTO PESSOA VALUES('CLEIDE','F','1979-10-13')
INSERT INTO PESSOA VALUES('MAFRA','M','1981-02-13')

SELECT @@IDENTITY -- GUARDA O ULTIMO IDENTITY INSERIDO NA SEÇÃO
GO

SELECT * FROM PESSOA

INSERT INTO TELEFONE VALUES('CEL','9879008',1)
INSERT INTO TELEFONE VALUES('COM','8757909',1)
INSERT INTO TELEFONE VALUES('CEL','9875890',2)
INSERT INTO TELEFONE VALUES('CEL','9347689',2)
INSERT INTO TELEFONE VALUES('COM','2998689',3)
INSERT INTO TELEFONE VALUES('COM','2098978',2)
INSERT INTO TELEFONE VALUES('CEL','9008679',3)
GO

SELECT * FROM TELEFONE
GO

-- CRIANDO A PROCEDURE ESTÁTICA
CREATE PROC SOMA
AS
	SELECT 10+10 AS SOMA
GO

-- EXEC PROCEDURE
SOMA
GO
-- OU
EXEC SOMA
GO

-- PROCEDURE COM PARAMETRO
CREATE PROC SOMA_PARAMETRO @NUM1 INT, @NUM2 INT
AS
	SELECT @NUM1 + @NUM2

GO

EXEC SOMA_PARAMETRO 1, 2
GO

-- EXCLUINDO PROCEDURE
DROP PROC SOMA_PARAMETRO
GO

-- PROCEDURES EM TABELAS
-- TRAZER OS TELEFONES DE ACORDO COM O TIPO PASSADO
CREATE PROC TELEFONES @TIPO CHAR(3)
AS
	SELECT NOME, NUMERO FROM PESSOA
	INNER JOIN TELEFONE 
	ON IDPESSOA = ID_PESSOA
	WHERE TIPO = @TIPO
GO

EXEC TELEFONES 'COM'
GO

-- PARAMETROS DE SAÍDA
-- RETORNAR O TIPO DO TELEFONE
CREATE PROC GETTIPO @TIPO CHAR(3), @CONTADOR INT OUTPUT
AS 
	SELECT @CONTADOR = COUNT(*)
	FROM TELEFONE
	WHERE TIPO = @TIPO
GO

-- TRASACTION SQL -> LINGUAGEM QUE O SQL TRABALHA
DECLARE @CONT INT
EXEC GETTIPO @TIPO = 'CEL', @CONTADOR = @CONT OUTPUT
SELECT @CONT
GO

-- ABREVIANDO
DECLARE @CONT INT
EXEC GETTIPO 'CEL', @CONT OUTPUT
SELECT @CONT
GO


-- PRECEDURE DE CADASTRO SIMULTANEO E TELEFONE E PESSOA
CREATE PROC CADASTRO @NOME VARCHAR(30), @SEXO CHAR(1), @NASCIMENTO DATE,
			@TIPO CHAR(3), @NUMERO CHAR(10)
AS
	DECLARE @FK INT
	
	INSERT INTO PESSOA VALUES(@NOME, @SEXO, @NASCIMENTO)
	-- SET @FK = @@IDENTITY
	SET @FK = (SELECT IDPESSOA FROM PESSOA 
				WHERE IDPESSOA = @@IDENTITY)
	INSERT INTO TELEFONE VALUES(@TIPO, @NUMERO, @FK)
GO

EXEC CADASTRO 'KLEBER', 'M', '1981-01-02', 'CEL', '9945733'
GO

SELECT * FROM PESSOA
LEFT JOIN TELEFONE
ON IDPESSOA = ID_PESSOA 
GO

-- TIPAGEM DE PARAMETROS
DECLARE
	@V_NUMERO NUMERIC(10,2) = 100.52,
	@V_DATA DATETIME = '20170207'
BEGIN
	PRINT 'VALOR NUMERICO: ' + CAST(@V_NUMERO AS VARCHAR)
	PRINT 'VALOR NUMERICO: ' + CONVERT(VARCHAR, @V_NUMERO)
	PRINT 'VALOR DE DATA: ' + CAST(@V_DATA AS VARCHAR)
	PRINT 'VALOR DE DATA: ' + CONVERT(VARCHAR, @V_DATA, 121)
	PRINT 'VALOR DE DATA: ' + CONVERT(VARCHAR, @V_DATA, 120)
	PRINT 'VALOR DE DATA: ' + CONVERT(VARCHAR, @V_DATA, 105) -- PTBR
END
GO

/* ATRIBUINDO RESULTADOS A UMA VARIAVEL */

CREATE TABLE CARROS(
	CARRO VARCHAR(20),
	FABRICANTE VARCHAR(30)
)
GO

INSERT INTO CARROS VALUES('KA','FORD')
INSERT INTO CARROS VALUES('FIESTA','FORD')
INSERT INTO CARROS VALUES('PRISMA','FORD')
INSERT INTO CARROS VALUES('CLIO','RENAULT')
INSERT INTO CARROS VALUES('SANDERO','RENAULT')
INSERT INTO CARROS VALUES('CHEVETE','CHEVROLET')
INSERT INTO CARROS VALUES('OMEGA','CHEVROLET')
INSERT INTO CARROS VALUES('PALIO','FIAT')
INSERT INTO CARROS VALUES('DOBLO','FIAT')
INSERT INTO CARROS VALUES('UNO','FIAT')
INSERT INTO CARROS VALUES('GOL','VOLKSWAGEN')
GO

SELECT COUNT(*) FROM CARROS
	WHERE FABRICANTE = 'FORD'
GO

DECLARE
	@V_CONT_FORD INT,
	@V_CONT_FIAT INT
BEGIN

	-- METODO 1 - O SELECT PRECISA RETORNAR UMA 
	-- SIMPLES COLUNA E UM SÓ RESULTADO
	SET @V_CONT_FORD = (SELECT COUNT(*) FROM CARROS
	WHERE FABRICANTE = 'FORD')

	PRINT 'QUANTIDADE FORD = ' + CAST(@V_CONT_FORD AS VARCHAR)

	-- METODO 2
	SELECT @V_CONT_FIAT = COUNT(*) FROM CARROS 
	WHERE FABRICANTE = 'FIAT'

	PRINT 'QUANTIDADE FIAT = ' + CAST(@V_CONT_FIAT AS VARCHAR)

END
GO


-- BLOCOS IF E ELSE
DECLARE
	@NUM INT = 6
BEGIN
	IF @NUM = 5
		PRINT 'NUMERO IGUAL A 5'
	ELSE
		PRINT('NUMERO DIFERENTE DE 5')
END
GO

-- CASE
DECLARE
	@NUM INT
BEGIN
	-- O CASE REPRESENTA UMA COLUNA
	SELECT 
	*, 
	CASE 
		WHEN FABRICANTE = 'FIAT' THEN 'FAIXA 1'
		WHEN FABRICANTE = 'FORD' THEN 'FAIXA 2'
		ELSE 'OUTRAS FAIXAS'
	END AS 'INFORMAÇÕES'
	FROM CARROS
END
GO

-- PROCEDURE
CREATE PROC VERIFICA_IGUALDADE @NUM INT
AS
	DECLARE
		@VAR INT  = 10
	BEGIN
		IF @NUM = 5
			PRINT 'NUMERO IGUAL A 5'
		ELSE
			PRINT('NUMERO DIFERENTE DE 5')
		IF @NUM > @VAR
			PRINT 'NUMERO MAIOR Q 10'
	END
GO

DROP PROC VERIFICA_IGUALDADE
GO

EXEC VERIFICA_IGUALDADE 11
GO

-- LOOPS WHILE
DECLARE
	@VAR INT
BEGIN
	SET @VAR = 0

	WHILE (@VAR < 5)
	BEGIN
		PRINT CAST(@VAR AS VARCHAR)
		SET @VAR = @VAR + 1
		-- SET @VAR += 1
	END
END
GO

























