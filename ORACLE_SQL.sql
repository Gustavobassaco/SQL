-- ORACLE SQL

/*	
	NO ORACLE SQL, EXISTEM DIVERSAS UNIDADES LÓGICAS
	ESSAS UNIDADES SÃO CHAMADAS DE SEGMENTOS E SÃO OBJETOS
	DOS BANCOS DE DADOS
	EX: TABELAS, ÍNDICES, VIEWS, PROCEDURES

	ESSES SEGMMENTOS SÃO ARMAZENADOS EM DATABLOCKS, QUE É A 
	UNIDADE MÍNIMA DE ARMAZENAMENTO. PODEM TEM TAMANHOS DE:
		2, 4, 8, 16, OU 32 KB
	
	CADA DATABLOCKS SÃO COMPOSTOS DE UM HEADER, ESPAÇO VAZIO
	OU DE REDUNDÂNCIA E ESPAÇO PARA DADOS.
	CASO UM DADO EXCEDA O LIMITE UM DATABLOCK, DENTRO DO HEADER
	EXISTE UM PONTEIRO PARA O PROXIMO DATABLOCK
	
	EM GERAL, BLOCOS MENORES TORNAM A GRAVAÇÃO MAIS RAPIDA (OLTP),
	ENQUANTO BLOCOS MAIORES AUXILIAM CONSULTAS MAIS RAPIDAS (OLAP)
	
	UM CONJUNTO DE DATABLOCKS FORMA UMA EXTENT E NÃO SÃO NECESSÁ
	RIAMENTE CONTINUOS
	
	OU SEJA, AO CRIAR UMA TABELA(SEGMENT), ELE OCUPA UM EXTENT, 
	COMPOSTO POR DATABLOCKS, OCUPANDO ESPAÇO EM DISCO

	TABELAS PRECISAM DE TABLESPACES PARA SEREM CRIADAS. CASO
	NÃO SEJA IDENTIFICADA, ELA SERA CRIADA POR PADRÃO DENTRO DA
	TABLESPACE SYSTEM
	
	AO CRIAR UMA TABLESPACE, OS ARQUIVOS CRIADOS SÃO EXPLICITADOS
	(DATAFILES)E O TAMANHO TOTAL DA SOMA DOS ARQUIVOS REPRESENTA 
	O TAMANHO DA TABLESPACE
	O -> L -> F

	OS DATAFILES SÃO DESTINADOS A DIFERENTES FUNÇÕES, DE AORDO COM
	A FUNÇÃO DA TABLESPACE
		TBS PERMANENTE: DICIONÁRIO DE DADOS -> METADADOS; DADOS DE APLICAÇÕES
		TBS TEMPORARIA: DADOS TEMPORARIOS
	
	EXISTE TMB O CONTROLFILE, QUE SÃO ARQ RESPONSAVEIS PELO CONTROLE
	DO FUNCIONAMENTO DA BASE DA DADOS ORACLE. TODA BASE DE DADOS
	DEVE TER PELO MENOS UM CONTROLFILE, PODENDO CHEGAR A 8 (IGUAIS). ELES 
	FORNECEM INFORMAÇÕES DE START UP E SHUT DOWN, INFORMANDO SE OS 
	DOIS PROCESSOS FORAM EXECUTADOS DE MANEIRA CORRETA E SINCRONA.
	ELES TAMBEM INFORMAM A LOCALIZAÇÃO DOS DATAFILES PARA QUE O 
	BANCO DE DADOS POSSA SER ABERTO. ELES TAMBEM ARMAZENAM INFORAÇÕES
	COMO O NOME DA DATABASE, A DATA DE CRIAÇÃO E A HORA E O ULTIMO
	CHECKPOINT OCORRIDO COM OS DATAFILES
	
	REDO LOG FILES: ARMAZENA AS TRANSAÇÕES EXECUTADAS E CONFIRMADAS 
	COM COMMIT. SÃO O LOG DAS TRANSAÇÕES. O OBJETIVO É PERMITIR A 
	MAIOR RECUPERAÇÃO DE DADOS COMITADOS. QUANDO EXECUTAMOS UM COMMIT
	, OS DADOS PERMANECEM EM MEMORIA, POIS O ACESSO A ELA É MAIS RÁPIDO
	DO QUE O ACESSO AO DISCO. SENDO ASSIM, OS DADOS COMITADOS SÃO 
	GRAVADOS TAMBEM NOS REDO LOGS, AFIMDE RECUPERAÇÃO EM CASO DE PERDAS
	ANTES DA SINCRONIZAÇÃO COM OS DATAFILES
	
	ACHIVE. COMO OS RADOLOG FUNCIONAM DE MANEIRA CIRCULAR, OS DADOS
	SÃO SOBRESCRITOS EM DETERMINADO MOMENTO. PARA EVITAR PERDA DE 
	DADOS, PODEMOS COLOCAR O BANCO DE DADOS EM MODO ARCHIVE, ONDE
	UM ARQUIVO É GERADO COM A CÓPIA DOS REDO A CADA MUDANÇA DE ARQ.
	O ARQ DE ARCHIVE NÃO É OBRIGATORIO MAS É AMPLAMENTE UTILIZADO
	EM AMBIENTES DE PRODUÇÃO
	
	ARQUIVOS DE PARAMETRO: SPFILE -> A INSTANCIA DO BD LÊ ESSE ARQ
	NO MOMENTO DE INICIALIZAÇÃO. ESSE ARQUIVO É BINÁRIO E DEICA OS 
	PARAMENTROS PERSISTENTES. É ALTERADO ATRAVES DE COMANDO NO ORACLE
	PFILE -> IDENTICO AO SPFILE, PORÉM PODE SER EDITADO PELO USER
	ATRAVES DE UM ARQUVIO
	ESCOPOS: NA MEMÓRIA, NA REINICIALIZAÇÃO, AMBOS
	
	PRINCIPAIS TABLESPACES:
	SYSTEM E SYSAUX - ARMAZENAM TODA A PARTE CORE DO BANCO, OU SEJA, 
	TODO O DICIONARIO DE DADOS É ARMAZENADO NESSAS DUAS TABLESPACES
	
	UNDO - TRABALHA COM A INTEGRIDADE DO BANOO DE DADOS, AUXILIANDO
	NA LEITURA CONSISTENTE. EXEMPLIFICANDO, OS DADOS QUE NÃO ESTÃO
	COMITADOS. ALGUMAS LEITURAS TAMBEM PODEM CHAMAR O TABLESPACE DE
	UNID DE TABLESPACE DE ROLLBACK
	
	TEMP - AUXILIA A MEMORIA DO ORACLE EM OPERAÇÕES MAIS PESADAS
	
	NO ORACLE, A MEMORIA É DIVIDA EM COMPARTILHADA, OQUE É UTILIZADA
	POR TODOS OS USUARIOS E PROCESSOS DO ORACLE (SGA), E A MEMORIA DEDICADA,
	ONDE CADA USUARIO POSSUI O SEU PROPRIO ESPAÇO, OU PROCESSO  (PGA).
	ELA EVITA O RETRABALHO DOS USUARIOS
	SGA:
		SHARED POOL -> ANALISE SINTATICA E SEMANTICA, DADOS DICIONARIO
			PLANO DE EXECUÇÃO (ARMAZENA AS QUERRYS REALIZADAS TMB)
		
		DATABASE BUFFER CACHE -> QUERRY -> JA FOI FEITA? SIM: DATABASE
			BUFFER CACHE. NÃO: LÊ OS BLOCOS NO HD COM MENOS PERFOR
			MANCE POIS O ACESSO À MEMORIA É MAIS RAPIDO
			ELE TMB ARMAZENDA OS DADOS COMITADOS POR USUARUISM QUE 
			SERÃO SINCRONIZADOS COM OS ARQ DBFs POR UM PROCESSO
			AO REALIZAR UMA OPERAÇÃO E EFETUAR UM COMMIT, OS BLOCOS
			DO DBBC NÃO SÃO GRAVADOS NA HORA EM DISCO, NESSE MOMENTO 
			É FEITA A GRAVAÇÃO NO REDO LOG E O DBBC MANTEM AINDA OS 
			BLOCOS ALTERADOS PARA QUE ESSES SEJAM GRAVADOS EM CONJUNTO
			COM OUTROS BLOCOS EM UM MOMENTO OPORTUNO
			
		REDO LOG BUFFER -> É A ÁREA DE MEMORIA CORRESPONDENTE AOS
			REDO LOGS NO DISCO. ASSIM QUE UMA TRANSAÇÃO É COMITADA, ELA
			É GUARDADA NO REDO LOG BUFFER QUE ESCREVERÁ NO ARQUIVO REDO 
			LOG NO DISCO
		
		LARGE POOL -> PARA OBJETOS GRANDES NÃO OCUPAREMA SHARED POOL,
			COMO POR EXEMPLO, ROTINAS DE BACKUP. A LARGE POOL TAMBEM 
			PERMITE O PARALELISMO NO ORACLE.
		
		JAVA POOL -> ARMAZENA CÓDIGOS JAVA E JVM
		
		STREAMS POOL -> ÁREA QUE ARMAZENA O SERVIÇO DE MENSAGENS PARA
			REPLICAÇÃO DE DADOS
		
		
	EXEMPLO PRATICO:
		UPDATE FUNCIONARIOS SET SALARIO = 5000 WHERE IDFUNC = 100
		
		A -> O PARSE DO SQL E CHECAGEM DO ACESSO AOS OBJETOS DO 
		DICIONARIO SÃO ARMAZENDADOS NO SHARED POOL
		
		B -> O BLOVO DE DADOS É LIDO NA DATABASE (DATABASE FILE)
		
		C -> UMA CÓPIA DO BLOCO É COLOCADA NA MEMÓRIA, NO DBBC. ELE
		PERMANECE EM LOCK
		
		D -> ANTES DO UPDATE OCORRER A TRASAÇÃO É GERADA NO 
		REDOLOG BUFFER
		
		E -> É CRIADO UM BLOCO DE UNDO COM O VALOR ANTIGO DO BLOCO
		
		F -> O VALOR DO BLOCO É ATUALIZADO
		
		G -> USUARIO RECEBE MENSAGEM NA TELA
		
		H1 -> AO EFETUAR UM ROOLBACK, O VALOR DO BLOCO DE UNDO, 
		SOBRESCREVE O BLCO NA MEMORIA E A TRANSAÇÃO DO REDOLOG
		É APAGADA E O LOCK RETIRADO
		
		H2 -> COMMIT: É GERADO UM NÚMERO ÚNICO DE SCN NO REDOLOG
		QUE CARACTERIZA A TRANSAÇÃO COMO ÚNICA
		
		I -> A TRANSAÇÃO É GRAVADA EM DISCO, NOS REDOLOG FILES
		
		J -> O REDELOG BUFFER É LIMPO
		
		K -> O LOCK É RETIRADO DO BLOCO COM SCN DA TRANSAÇÃO
		
		L -> A ÁREA DE UNDO, NESSE MOMENTO PODE SER SOBRESCRITA
		
		M -> O VALOR É SINCRONIZADO COM OS DATAFILES
		
		
*/


-- usuario do banco de dados
show user;

-- tabela dummy, não pode pois tudo deve vir de uma tabela
select 1+1; -- ERRADO

select 1 + 1 AS SOMA from DUAL;

-- VERIFICANDO O AMBIENTE
-- B023 -> 32 BITS
-- B047 -> 64 BITS
SELECT METADATA FROM SYS.KOPM$;

-- DICIONARIO DE DADOS
SELECT * FROM DICT;

-- INSTANCIA UNICA - RAC
-- PERGUNTA SE ESTÁ USANDO PARALELISMO
SELECT PARALLEL FROM V$INSTANCE;

-- ESTRUTURA DE MEMORIA
SELECT COMPONENT, CURRENT_SIZE, MIN_SIZE, MAX_SIZE
FROM V$SGA_DYNAMIC_COMPONENTS;

-- CONECTANDO A OUTRO BANCO DE DADOS
SQLPLUS SYSTEM/SENHA@NOMEBANCO
ORACLE_SID=XE

-- NOME DO BANCO DE DADOS
SELECT NAME FROM V$DATABASE; -- XE

-- VERSÃO DO DB
SELECT BANNER FROM V$VERSION;

-- VERIFICAR PROVILEGIOS DO USUARIO
SELECT * FROM USER_SYS_PRIVS;

-- TABELAS DO USSUARIO
SELECT TABLE_NAME FROM USER_TABLES;


-- ARMAZENAMENTO
-- LOGICO -> TABLESPACE -> SEGMENTOS(OBJETOS) ->
-- EXTENSOES (ESPACO) -> BLOCOS (DO SO)

-- FISICO -> DATAFILES
-- NÃO PODEMOS DETERMINAR EM QUAL ARQ UM OBJ FICARÁ
DROP TABLE CURSOS;

CREATE TABLE CURSOS(
    IDCURSO INT PRIMARY KEY,
    NOME VARCHAR2(30),
    CARGA INT
) TABLESPACE USERS;

CREATE TABLE TESTE(
    IDTESTE INT,
    NOME VARCHAR(30)
);

SELECT * FROM CURSOS;

-- DICIONARIO DE DADOS
SELECT TABLE_NAME, TABLESPACE_NAME FROM USER_TABLES
WHERE TABLE_NAME = 'CURSOS';

SELECT TABLE_NAME, TABLESPACE_NAME FROM USER_TABLES
WHERE TABLE_NAME = 'TESTE'; -- SYSTEM

-- TODO OBJETO É CRIADO POR PADRÃO NA TABLESPACE
-- USERS, EXCETO QUANDO SE ESTA LOGADO COM O USUARIO
-- SYSTEM -> POR PADRÃO SERÁ CRIADO EM SYSTEM

-- TABLESPACE É LOGICA, DBF É FISICO
-- É POSSIVEL APONTAR UM TABLESPACE PARA MAIS DE UM DBF


SELECT SEGMENT_NAME, SEGMENT_TYPE, TABLESPACE_NAME,
BYTES, BLOCKS, EXTENTS FROM USER_SEGMENTS
WHERE SEGMENT_NAME = 'CURSOS';

-- BACKUP	
CREATE TABLESPACE RECURSOS_HUMANOS
DATAFILE 'C:\Data\RH_01.dbf'
SIZE 100M AUTOEXTEND
ON NEXT 100M
MAXSIZE 4096M;

ALTER TABLESPACE RECURSOS_HUMANOS
ADD DATAFILE 'C:\DATA\RH_02.DBF'
SIZE 200M AUTOEXTEND
ON NEXT 100M
MAXSIZE 4096M;
-- NESTE CASO, DOIS ARQUIVOS FISICOS APONTANDO PARA
-- UMA TABLESPACE (LÓGICO)

-- NOME E ARQ DA TABLESPACE
SELECT TABLESPACE_NAME, FILE_NAME FROM DBA_DATA_FILES;

-- SEQUENCES, COMO O AUTO_INCREMENT DO MYSQL
-- OU IDENTITY DO SQL SERVER, PORÉM É DIFERENTE
-- DIFERENTE DOS DOIS QUE PERTENCEM À TABELA,
-- SEQUENCES PERTENCEM AO DB INTEIRO
CREATE SEQUENCE SEQ_GERAL 
START WITH 100
INCREMENT BY 10;

CREATE TABLE FUNCIONARIOS(
    ID_FUNCIONARIO INT PRIMARY KEY,
    NOME VARCHAR2(30)
)TABLESPACE RECURSOS_HUMANOS;

INSERT INTO FUNCIONARIOS VALUES(SEQ_GERAL.NEXTVAL,'JOAO');
INSERT INTO FUNCIONARIOS VALUES(SEQ_GERAL.NEXTVAL,'CLARA');
INSERT INTO FUNCIONARIOS VALUES(SEQ_GERAL.NEXTVAL,'LIA');

SELECT * FROM FUNCIONARIOS;
-- EFETUAR COMMIT
 
-- CRIANDO TABLESPACE DE MARKETING
CREATE TABLESPACE MARKETING
DATAFILE 'C:\Data\MKT_01.dbf'
SIZE 100M AUTOEXTEND
ON NEXT 100M
MAXSIZE 4096M;
 

CREATE TABLE CAMPANHAS(
    IDCAMPANHA INT PRIMARY KEY,
    NOME VARCHAR2(30)
)TABLESPACE MARKETING;

INSERT INTO CAMPANHAS VALUES(SEQ_GERAL.NEXTVAL,'PRIMAVERA');
INSERT INTO CAMPANHAS VALUES(SEQ_GERAL.NEXTVAL,'VERÃO');
INSERT INTO CAMPANHAS VALUES(SEQ_GERAL.NEXTVAL,'INVERNO');

SELECT * FROM CAMPANHAS;
SELECT * FROM FUNCIONARIOS;

-- REALIZANDO MANUTENÇÃO
-- COLOCANDO A TABLESPACE OFFLINE
ALTER TABLESPACE RECURSOS_HUMANOS OFFLINE;
-- COPIE OS ARQUIVOS PARA O DIRETORIO DE PRODUÇÃO 

-- APONTAR PARA O DICIONARIO DE DADOS
ALTER TABLESPACE RECURSOS_HUMANOS 
RENAME DATAFILE  
'C:\Data\RH_01.DBF' TO 
'C:\Data_producao\RH_01.DBF';

ALTER TABLESPACE RECURSOS_HUMANOS 
RENAME DATAFILE  
'C:\Data\RH_02.DBF' TO 
'C:\Data_producao\RH_02.DBF';

-- COLOCANDO A TABLESPACE EM PRODUÇÃO
ALTER TABLESPACE RECURSOS_HUMANOS ONLINE;

DROP TABLE ALUNO;
CREATE TABLE ALUNO (
    IDALUNO INT PRIMARY KEY,
    NOME VARCHAR2(30),
    EMAIL VARCHAR2(30),
    SALARIO NUMBER(10,2)
);

CREATE SEQUENCE SEQ_EX
START WITH 100
INCREMENT BY 1;

INSERT INTO ALUNO (IDALUNO, NOME, EMAIL, SALARIO)
VALUES (SEQ_EX.NEXTVAL, 'João Silva', 'joao.silva@email.com', 2500.00);
INSERT INTO ALUNO (IDALUNO, NOME, EMAIL, SALARIO)
VALUES (SEQ_EX.NEXTVAL, 'Ana Costa', 'ana.costa@email.com', 3200.50);
INSERT INTO ALUNO (IDALUNO, NOME, EMAIL, SALARIO)
VALUES (SEQ_EX.NEXTVAL, 'Carlos Pereira', 'carlos.pereira@email.com', 2800.75);
INSERT INTO ALUNO (IDALUNO, NOME, EMAIL, SALARIO)
VALUES (SEQ_EX.NEXTVAL, 'Maria Oliveira', 'maria.oliveira@email.com', 3400.00);
INSERT INTO ALUNO (IDALUNO, NOME, EMAIL, SALARIO)
VALUES (SEQ_EX.NEXTVAL, 'Lucas Souza', 'lucas.souza@email.com', 2950.25);

SELECT * FROM ALUNO;

SELECT TABLE_NAME, TABLESPACE_NAME FROM USER_TABLES
WHERE TABLE_NAME = 'ALUNO';

-- pseudo colunas 
-- ROWID E ROWNUM
SELECT ROWID, IDALUNO, NOME, EMAIL FROM ALUNO;

-- ROWNUM SERVE APRA PAGINAÇÃO DE REGISTROS
SELECT ROWID, ROWNUM, IDALUNO, NOME, EMAIL FROM ALUNO;

SELECT IDALUNO, NOME, EMAIL FROM ALUNO
WHERE ROWNUM < 3 ;

-- PROCEDURE
CREATE OR REPLACE PROCEDURE BONUS(
        P_ID ALUNO.IDALUNO%TYPE,
        P_PORCENTAGEM NUMBER)
AS
BEGIN
    UPDATE ALUNO SET SALARIO = SALARIO + 
    (SALARIO * (P_PORCENTAGEM/100))
    WHERE P_ID = IDALUNO;
END;

SELECT * FROM ALUNO;

CALL BONUS(101, 20);

-- AS TRIGGER DEVEM TER O TAMANHO DE 32K
-- NÃO EXECUTE COMANDOS DE DTL - COMMITM ROLLBACK E SAVEPOINTS
CREATE OR REPLACE TRIGGER CHECK_SALARIO
BEFORE INSERT OR UPDATE ON ALUNO
FOR EACH ROW
BEGIN
    IF :NEW.SALARIO > 200 THEN
        RAISE_APLICATION_ERROR(-20000, 'VALOR INCORRETO')
    END IF;
END;
/

-- VERIFICANDO ERROS:
SHOW ERRORS;

CREATE OR REPLACE TRIGGER CHECK_SALARIO
BEFORE INSERT OR UPDATE ON ALUNO
FOR EACH ROW
BEGIN
    IF :NEW.SALARIO > 200 THEN
        RAISE_APPLICATION_ERROR(-20000, 'VALOR INCORRETO');
    END IF;
END;
/

INSERT INTO ALUNO (IDALUNO, NOME, EMAIL, SALARIO)
VALUES (SEQ_EX.NEXTVAL, 'TESTE_TRIGGER', 'lucas.souza@email.com', 2950.25);

-- OBTENDO O NOME E TEXTPO DA TRIGGER
SELECT TRIGGER_NAME, TRIGGER_BODY FROM USER_TRIGGERS;

-- TRIGGER DE EVENTOS
CREATE TABLE AUDITORIA(
    DATA_LOGIN DATE,
    LOGIN VARCHAR2(30)
);

SELECT * FROM AUDITORIA;

CREATE OR REPLACE PROCEDURE LOGPROC AS
BEGIN 
    INSERT INTO AUDITORIA(DATA_LOGIN, LOGIN)
    VALUES(SYSDATE, USER);
END LOGPROC;
/

SELECT USER, SYSDATE FROM DUAL;

CREATE OR REPLACE TRIGGER LOG_TRIGGER 
AFTER LOGON ON DATABASE
CALL LOGPROC
/


-- FALHA DE LOGON -> SEGURANÇA
CREATE OR REPLACE TRIGGER FALHA_LOGON
AFTER SERVERERROR
ON DATABASE
BEGIN
    IF(IS_SERVERERROR(1017)) THEN
        INSERT INTO AUDITORIA(DATA_LOGIN, LOGIN)
        VALUES(SYSDATE, 'ORA-1017');
    END IF;
END FALHA_LOGON;
/

-- 1004 DEAFAULT USERNAME FEATURE NOT SUPORTED
-- 1005 PASSWORD NULL
-- 1045 PRIVELIGIO INSUFICIENTE

-- TRIGGER DE DML
CREATE TABLE USUARIO(
    IDUSUARIO INT PRIMARY KEY,
    NOME VARCHAR2(30)
);

CREATE TABLE BKP_USUARIO(
    IDBKP INT PRIMARY KEY,
    NOME VARCHAR2(30)
);

CREATE OR REPLACE TRIGGER HIST_USUARIO
BEFORE DELETE ON USUARIO
FOR EACH ROW
BEGIN
    INSERT INTO BKP_USUARIO VALUES(:OLD.IDUSUARIO, :OLD.NOME);
END;
/



INSERT INTO USUARIO VALUES(SEQ_EX.NEXTVAL, 'VALERIA');
INSERT INTO USUARIO VALUES(SEQ_EX.NEXTVAL, 'HOMMER');
INSERT INTO USUARIO VALUES(SEQ_EX.NEXTVAL, 'VALDISCREIA');
COMMIT;

SELECT * FROM USUARIO;

DELETE FROM USUARIO WHERE IDUSUARIO = 121;

SELECT * FROM BKP_USUARIO;

-- OPERAÇÕES COM VIEWS
CREATE TABLE CLIENTE(
    IDCLIENTE INT PRIMARY KEY,
    NOME VARCHAR2(30),
    SEXO CHAR(1)
);

INSERT INTO CLIENTE VALUES(1, 'NOME1', 'M');
INSERT INTO CLIENTE VALUES(2, 'NOME2', 'F');
INSERT INTO CLIENTE VALUES(3, 'NOME3', 'M');
COMMIT;

SELECT * FROM CLIENTE;

CREATE OR REPLACE VIEW V_CLIENTE 
AS SELECT IDCLIENTE, NOME, SEXO FROM CLIENTE;
   
SELECT IDCLIENTE, NOME, SEXO FROM V_CLIENTE; 

-- VIEW TAMBEM PODEM INSERIR DADOS, QUANDO NÃO POSSUEM JOINS
INSERT INTO V_CLIENTE VALUES(4, 'NOME4', 'F');

-- NÃO DEIXANDO SER USADA PARA ESCRITA
CREATE OR REPLACE VIEW V_CLIENTE2
AS  SELECT IDCLIENTE, NOME, SEXO FROM CLIENTE
    WITH READ ONLY;
    
-- NÃO É POSSIVEL
INSERT INTO V_CLIENTE2 VALUES(5, 'NOME5', 'F');

-- VIEW DE JOIN
CREATE TABLE TELEFONE(
    IDTELEFONE INT PRIMARY KEY,
    NUMERO VARCHAR2(15),
    ID_CLIENTE INT
);

ALTER TABLE TELEFONE ADD CONSTRAINT FK_CLIENTE_TELEFONE
FOREIGN KEY(ID_CLIENTE) REFERENCES CLIENTE;

CREATE OR REPLACE VIEW RELATORIO
AS
SELECT NOME, SEXO, NVL(NUMERO, '----')  AS NUMERO FROM CLIENTE
LEFT JOIN TELEFONE
ON IDCLIENTE = ID_CLIENTE;

INSERT INTO TELEFONE VALUES(1, '2342234', 1);
INSERT INTO TELEFONE VALUES(2, '5345345', 1);
INSERT INTO TELEFONE VALUES(3, '2634334', 2);

SELECT * FROM RELATORIO;

-- EM ALGUNS CENÁRIOS É INTERESSANTE REALIZAR A INSERÇÃO
-- DE MUITO DADOS. NESSES CASOS PODE-SE QUERER ADICIONAR
-- DADOS SEM QUE A CHECAGEM DA CHAVE ESTRANGEIRA EM UMA 
-- TABELA COM JOIN DE FATO EXISTA DURANTE OS INSERT, E 
-- SEJA REALIZADA APENAS APÓS TODOS OS INSERTS OCORREREM

-- DEFERRABLE CONSTRAINTS
CREATE TABLE FUNCIONARIO(
    IDFUNCIONARIO INT CONSTRAINT PK_FUNCIONARIO PRIMARY KEY,
    NOME VARCHAR2(50)
);

DROP TABLE TELEFONE;

CREATE TABLE TELEFONE(
    IDTELEFONE INT PRIMARY KEY,
    NUMERO VARCHAR2(15),
    ID_FUNCIONARIO INT
);

ALTER TABLE TELEFONE ADD CONSTRAINT FK_TELEFONE_FUNCIONARIO
FOREIGN KEY (ID_FUNCIONARIO) REFERENCES FUNCIONARIO;

INSERT INTO FUNCIONARIO (IDFUNCIONARIO, NOME) VALUES (1, 'João Silva');
INSERT INTO FUNCIONARIO (IDFUNCIONARIO, NOME) VALUES (2, 'Ana Costa');
INSERT INTO FUNCIONARIO (IDFUNCIONARIO, NOME) VALUES (3, 'Carlos Pereira');
INSERT INTO FUNCIONARIO (IDFUNCIONARIO, NOME) VALUES (4, 'Maria Oliveira');
INSERT INTO FUNCIONARIO (IDFUNCIONARIO, NOME) VALUES (5, 'Lucas Souza');

INSERT INTO TELEFONE (IDTELEFONE, NUMERO, ID_FUNCIONARIO) VALUES (1, '123456789', 1);
INSERT INTO TELEFONE (IDTELEFONE, NUMERO, ID_FUNCIONARIO) VALUES (2, '987654321', 2);
INSERT INTO TELEFONE (IDTELEFONE, NUMERO, ID_FUNCIONARIO) VALUES (3, '555123456', 3);
INSERT INTO TELEFONE (IDTELEFONE, NUMERO, ID_FUNCIONARIO) VALUES (4, '999876543', 4);
INSERT INTO TELEFONE (IDTELEFONE, NUMERO, ID_FUNCIONARIO) VALUES (5, '444567890', 5);

SELECT * FROM FUNCIONARIO
LEFT JOIN TELEFONE
ON IDFUNCIONARIO = ID_FUNCIONARIO;

-- A CONSTRAINT DE INTEGRIDADE REFERENCIAL FK CHECA A INTEGRIDADE
-- LOGO APOS O COMANDO DE DML (INSERT) -> NÃO POSSIBILITANDO A 
-- INSERÇÃO DE  REGISTROS SEM REFERENCIA
-- ERRO
INSERT INTO TELEFONE (IDTELEFONE, NUMERO, ID_FUNCIONARIO) VALUES (6, '345345', 10);

-- VERIFICANDO O ESTADO DAS CONSTRAINTS
SELECT CONSTRAINT_NAME, DEFERRABLE, DEFERRED
FROM USER_CONSTRAINTS 
WHERE TABLE_NAME IN('FUNCIONARIO', 'TELEFONE');

--DEFERRABLE -> SE PODE TER VERIFICAÇÃO ATRASADA
--DEFERED -> SE A VERIFICAÇÃO ESTÁ OU NÃO COMO 
--           IMEDIATAMENTE OPERAÇÕES DE DML

-- APAGANDO A CONSTRAINT
ALTER TABLE TELEFONE DROP CONSTRAINT FK_TELEFONE_FUNCIONARIO;

-- RECRIANDO A CONSTRAINT DEFERRABLE
-- ELA PODE SER ATRASADA (DTL), MAS AINDA N ESTÁ SETADA ASSIM
ALTER TABLE TELEFONE ADD CONSTRAINT FK_TELEFONE_FUNCIONARIO
FOREIGN KEY (ID_FUNCIONARIO) REFERENCES FUNCIONARIO
DEFERRABLE;

-- ERRO
INSERT INTO TELEFONE (IDTELEFONE, NUMERO, ID_FUNCIONARIO) VALUES (6, '345345', 10);

-- MUDANDO PARA DTL
-- SÓ ATÉ O PROXIMO COMMIT
SET CONSTRAINT ALL DEFERRED;

-- NESSE CASO  A VERIFICÃO SERÁ REALIZADA NO MOMENTO DO COMMIT
SELECT * FROM TELEFONE;

-- OCORREU UM ROLLBACK
COMMIT;








